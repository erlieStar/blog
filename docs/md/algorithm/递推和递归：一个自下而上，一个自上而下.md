# 递推和递归：一个自下而上，一个自上而下
![请添加图片描述](https://img-blog.csdnimg.cn/2777d6b90be24202914af58b238f0e4e.jpg?)
## 解决问题的思路不同
**递推和递归是常见的解决问题的思路，在很多算法中都会用到，例如DFS算法基于递归实现，动态规划算法基于递推实现**。

**递推是从上到下解决问题**，如想知道一个国家有多少人，我们从村这个一个行政级别开始，依次向上汇报，最后到国这个级别就能知道一个国家有多少人

**递归是从上到下解决问题**，如想知道一个国家有多少人。国家发布命令让各个省上报各自的人数，各个省又发布命令让各自市上报各自的人数，依次类推，最后到达村这个级别，开始统计自己的人数（递推出口），统计完后逐级上报，最后到国这个级别就能知道一个国家有多少人

![请添加图片描述](https://img-blog.csdnimg.cn/279125dee1fa4ddd8433627d48e1a014.png?)
## 爬楼梯
题目地址：70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

```java
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
我们依次从第1阶开始依次计算方法，第1阶有1种方法，第2阶有2种方法，那么第3阶呢？

第3阶只能从第1阶或者第2阶踏过来，所以到第3阶的方法数为到第1阶或者到第2阶的方法数之和。
第4阶只能从第2阶或者第3阶踏过来，所以到第4阶的方法数为到第2阶或者到第3阶的方法数之和。

**依次类推dp[i] = d[i - 1] + dp[i - 2]（dp[i]为到第i阶的方法数）**

学了动态规划后，你就能会发现递推就是简单版的动态规划
```java
public int climbStairs(int n) {
    if (n == 1 || n == 2) {
        return n;
    }
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
我们用递推的思路来写一下实现，到n阶的方法数为到n-1阶和到n-2阶的和，递归的出口是第1阶有1种方法，第2阶有2种方法。

```java
public int climbStairs(int n) {
    if (n == 1 || n == 2) {
        return n;
    }
    return climbStairs(n - 1) + climbStairs(n - 2);
}
```
**在大多数情况下，递推解决问题的思路比较简单，代码也比较简洁，但是效率比较低（函数调用），同时也会有很多重叠子问题。递推的实现思路比较复杂，但是效率比较高。** 参见二叉树的前中后序的递归调用和非递归调用

![请添加图片描述](https://img-blog.csdnimg.cn/950e12abfcba49aba174283f49ff08df.png?)

如图，当通过递归的方式求到第5级台阶的方法数时，到第3级台阶的方法数被算了2次，所以我们可以使用额外空间将结算得到的结果缓存下来，避免重复计算（即备忘录算法）

```java
class Solution {

    // 数组大小按照题目的n确定
    int[] visit = new int[100];

    public int climbStairs(int n) {
        if (visit[n] != 0) {
            return visit[n];
        }
        if (n == 1 || n == 2) {
            return n;
        }
        visit[n] = climbStairs(n - 1) + climbStairs(n - 2);
        return visit[n];
    }

}
```


