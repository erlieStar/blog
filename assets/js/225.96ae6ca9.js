(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{626:function(t,s,a){"use strict";a.r(s);var r=a(56),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redis实战-如何保证缓存和数据库的一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实战-如何保证缓存和数据库的一致性"}},[t._v("#")]),t._v(" Redis实战：如何保证缓存和数据库的一致性？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/b1bf2348609b487394a338bb978aaa1c.jpeg",alt:"在这里插入图片描述"}})]),t._v(" "),a("h2",{attrs:{id:"先更新数据库还是先更新缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库还是先更新缓存"}},[t._v("#")]),t._v(" 先更新数据库还是先更新缓存？")]),t._v(" "),a("p",[a("strong",[t._v("先说最基本的策略，一定要给缓存设置一个过期时间，避免异常情况下数据库和缓存长时间不一致")])]),t._v(" "),a("p",[t._v("为了保证缓存和数据库的实时一致，我们不能用定时任务来更新缓存，我们要同时更新数据库和缓存，对应的方案有如下两种")]),t._v(" "),a("ol",[a("li",[t._v("先更新缓存，再更新数据库")]),t._v(" "),a("li",[t._v("先更新数据库，后更新缓存")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/96727334009c48e480e6c8f084bd6f14.png",alt:"在这里插入图片描述"}}),t._v(" "),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/071e2433d5d046ad80b7e0f976a7f31f.png",alt:"在这里插入图片描述"}}),t._v("\n如图所以，不同颜色的线代表不同的线程。无论是先更新数据库还是先更新缓存都会造成不一致的情况。针对这种不一致的情况，我们可以对更新数据库和缓存的操作加一个分布式锁，这样就能保证数据的一致性")]),t._v(" "),a("p",[t._v("除了并发的情况，我们还需要考虑异常的情况。比如更新数据库成功了，更新缓存失败了")]),t._v(" "),a("p",[t._v("基于内存缓存利用率的角度，我们一般不会采用同步更新的操作，因为有可能更新完的缓存并不一定会马上读取，导致缓存中缓存了大量无用的数据，降低缓存命中率。所以我们可以考虑"),a("strong",[t._v("删除缓存")])]),t._v(" "),a("h2",{attrs:{id:"先更新数据库还是先删除缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库还是先删除缓存"}},[t._v("#")]),t._v(" 先更新数据库还是先删除缓存？")]),t._v(" "),a("p",[t._v("删除缓存对应的方案也有两种")]),t._v(" "),a("ol",[a("li",[t._v("先删除缓存，后更新数据库")]),t._v(" "),a("li",[t._v("先更新数据库，后删除缓存")])]),t._v(" "),a("h3",{attrs:{id:"先删除缓存后更新数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先删除缓存后更新数据库"}},[t._v("#")]),t._v(" 先删除缓存后更新数据库")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/02f05f91bb024434a5c1b7b665b1e163.png",alt:"在这里插入图片描述"}}),t._v("\n可以看到还是会有数据不一致的情况，为了解决这种情况，可以使用延迟双删\n"),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/15051d27b61a4ba2926538048604554f.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("主要思路为删除数据库中的值后等待一段时间再删除一次缓存。"),a("strong",[t._v("这个等待的时间需要保证删除的时间点在写入旧缓存的时间点后面，所以这个等待的时间是难以估计的，极端情况下，仍然会出现缓存不一致的情况")])]),t._v(" "),a("h3",{attrs:{id:"先更新数据库-后删除缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-后删除缓存"}},[t._v("#")]),t._v(" 先更新数据库，后删除缓存")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/e43ff7a1d3614038a5bc7e61c0e989de.png",alt:"在这里插入图片描述"}}),t._v("\n从上图看，还是会存在数据不一致的情况，但是在实际中这个问题出现的概率并不高，因为要满足如下3个条件")]),t._v(" "),a("ol",[a("li",[t._v("缓存刚好失效")]),t._v(" "),a("li",[t._v("读写请求并发")]),t._v(" "),a("li",[t._v("更新数据库+删除缓存的时间，要比读数据库+写缓存时间短")])]),t._v(" "),a("p",[t._v("条件3发生的概率是很低的，因为写数据库要加锁，耗费的时间都比较长。"),a("strong",[t._v("所以我们一般情况下会采用先更新数据库+再删除缓存的方案")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/direct/83048acbedad445a9643bb2cdddc1540.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("我们接着来考虑异常的情况，如果保证更新数据库+再删除缓存能同时成功？有如下两种方案")]),t._v(" "),a("ol",[a("li",[t._v("重试。删除缓存失败后，把重试请求发到消息队列中，由专门的消费者负责重试，直到成功")]),t._v(" "),a("li",[t._v("订阅mysql binlog，再删除缓存")])])])}),[],!1,null,null,null);s.default=v.exports}}]);