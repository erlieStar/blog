(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{493:function(e,s,t){"use strict";t.r(s);var v=t(56),_=Object(v.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"面试官-redis中过期的key是怎么被删除的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试官-redis中过期的key是怎么被删除的"}},[e._v("#")]),e._v(" 面试官：Redis中过期的key是怎么被删除的？")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201108181755982.png?",alt:"在这里插入图片描述"}})]),e._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),t("p",[e._v("我们可以给Redis中的key设置过期时间，那么当key过期了，它在什么时候会被删除呢？")]),e._v(" "),t("p",[e._v("如果让我们写Redis过期策略，我们会想到如下三种方案")]),e._v(" "),t("ol",[t("li",[e._v("定时删除，在设置键的过期时间的同时，创建一个定时器。当键的过期时间来临时，立即执行对键的删除操作")]),e._v(" "),t("li",[e._v("惰性删除，每次获取键的时候，判断键是否过期，如果过期的话，就删除该键，如果没有过期，则返回该键")]),e._v(" "),t("li",[e._v("定期删除，每隔一段时间，对键进行一次检查，删除里面的过期键")])]),e._v(" "),t("p",[e._v("定时删除策略对CPU不友好，当过期键比较多的时候，Redis线程用来删除过期键，会影响正常请求的响应")]),e._v(" "),t("p",[e._v("惰性删除读CPU是比较有好的，但是会浪费大量的内存。如果一个key设置过期时间放到内存中，但是没有被访问到，那么它会一直存在内存中")]),e._v(" "),t("p",[e._v("定期删除策略则对CPU和内存都比较友好")]),e._v(" "),t("h2",{attrs:{id:"redis中key的过期策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis中key的过期策略"}},[e._v("#")]),e._v(" Redis中key的过期策略")]),e._v(" "),t("p",[e._v("redis过期key的删除策略选择了如下两种")]),e._v(" "),t("ol",[t("li",[e._v("惰性删除")]),e._v(" "),t("li",[e._v("定期删除")])]),e._v(" "),t("h3",{attrs:{id:"惰性删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除"}},[e._v("#")]),e._v(" 惰性删除")]),e._v(" "),t("p",[e._v("客户端在访问key的时候，对key的过期时间进行校验，如果过期了就立即删除")]),e._v(" "),t("h3",{attrs:{id:"定期删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定期删除"}},[e._v("#")]),e._v(" 定期删除")]),e._v(" "),t("p",[e._v("Redis会将设置了过期时间的key放在一个独立的字典中，定时遍历这个字典来删除过期的key，遍历策略如下")]),e._v(" "),t("ol",[t("li",[e._v("每秒进行10次过期扫描，每次从过期字典中随机选出20个key")]),e._v(" "),t("li",[e._v("删除20个key中已经过期的key")]),e._v(" "),t("li",[e._v("如果过期key的比例超过1/4，则进行步骤一")]),e._v(" "),t("li",[e._v("每次扫描时间的上限默认不超过25ms，避免线程卡死")])]),e._v(" "),t("p",[t("strong",[e._v("因为Redis中过期的key是由主线程删除的，为了不阻塞用户的请求，所以删除过期key的时候是少量多次")]),e._v("。源码可以参考expire.c中的activeExpireCycle方法")]),e._v(" "),t("h2",{attrs:{id:"为什么要了解redis过期key的删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要了解redis过期key的删除策略"}},[e._v("#")]),e._v(" 为什么要了解redis过期key的删除策略？")]),e._v(" "),t("p",[e._v("只有一个目的，让你知道"),t("strong",[e._v("设置key的过期时间为一个随机范围，不能都在同一时间过期")]),e._v("，不然频繁的扫描过期字典会造成客户端的请求出现卡顿")])])}),[],!1,null,null,null);s.default=_.exports}}]);